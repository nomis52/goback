<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>d.ne4.org Backup Automation</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent-blue: #3b82f6;
            --accent-green: #22c55e;
            --accent-yellow: #eab308;
            --accent-red: #ef4444;
            --border-color: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: none;
            padding: 0.75rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        h1 span {
            color: var(--accent-blue);
        }

        .last-updated {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .build-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .card {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .card-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.on { background-color: var(--accent-green); }
        .status-dot.off { background-color: var(--accent-red); }
        .status-dot.unknown { background-color: var(--text-secondary); }
        .status-dot.running { background-color: var(--accent-blue); }
        .status-dot.idle { background-color: var(--accent-green); }
        .status-dot.scheduled { background-color: var(--accent-blue); }
        .status-dot.not-scheduled { background-color: var(--text-secondary); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .status-value.on { color: var(--accent-green); }
        .status-value.off { color: var(--accent-red); }
        .status-value.running { color: var(--accent-blue); }

        .status-detail {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background-color: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #2563eb;
        }

        .btn-primary:disabled {
            background-color: var(--bg-card);
            color: var(--text-secondary);
            cursor: not-allowed;
        }

        .section {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            overflow-x: auto;
            margin-bottom: 1rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 1rem;
            font-weight: 600;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            text-align: left;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background-color: var(--bg-card);
            white-space: nowrap;
        }

        td {
            padding: 0.5rem 0.75rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        tr:hover {
            background-color: var(--bg-card);
        }

        tr.log-details:hover {
            background-color: var(--bg-primary) !important;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 9999px;
        }

        .badge-success {
            background-color: rgba(34, 197, 94, 0.2);
            color: var(--accent-green);
        }

        .badge-error {
            background-color: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .badge-running {
            background-color: rgba(59, 130, 246, 0.2);
            color: var(--accent-blue);
        }

        .badge-pending {
            background-color: rgba(148, 163, 184, 0.2);
            color: var(--text-secondary);
        }

        .badge-skipped {
            background-color: rgba(234, 179, 8, 0.2);
            color: var(--accent-yellow);
        }

        .empty-state {
            text-align: center;
            padding: 1.5rem;
            color: var(--text-secondary);
        }

        #currentWorkflowEmpty {
            display: none;
        }

        #currentWorkflowEmpty:not(.hidden) {
            display: block;
        }

        .error-message {
            color: var(--accent-red);
            font-size: 0.75rem;
        }

        .duration {
            font-family: 'SF Mono', Monaco, monospace;
            color: var(--text-secondary);
        }

        .timestamp {
            white-space: nowrap;
        }

        .activity-name {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.875rem;
        }

        .hidden {
            display: none;
        }

        .tabs {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }

        .tab {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .config-container {
            padding: 0.75rem 1rem;
        }

        .expandable-row {
            cursor: pointer;
        }

        .expandable-row:hover {
            background-color: var(--bg-card) !important;
        }

        .log-details {
            background-color: var(--bg-primary);
            border-top: 1px solid var(--border-color);
        }

        .log-details-content {
            padding: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            font-family: 'SF Mono', Monaco, Consolas, monospace;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
            display: flex;
            gap: 0.5rem;
            line-height: 1.4;
        }

        .log-time {
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .log-level {
            font-weight: 600;
            flex-shrink: 0;
            width: 50px;
        }

        .log-level.DEBUG { color: var(--text-secondary); }
        .log-level.INFO { color: var(--accent-blue); }
        .log-level.WARN { color: var(--accent-yellow); }
        .log-level.ERROR { color: var(--accent-red); }

        .log-message {
            color: var(--text-primary);
            flex: 1;
        }

        .log-attributes {
            margin-left: 2.5rem;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .log-attr-key {
            color: var(--accent-blue);
        }

        .chevron-icon {
            transition: transform 0.2s;
            display: inline-block;
        }

        .chevron-icon.expanded {
            transform: rotate(90deg);
        }

        .config-actions {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .btn-secondary {
            background-color: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--border-color);
        }

        pre {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'SF Mono', Monaco, Consolas, monospace;
            font-size: 0.875rem;
            line-height: 1.5;
            color: var(--text-primary);
        }

        .config-status {
            font-size: 0.875rem;
            margin-top: 0.75rem;
        }

        @media (max-width: 640px) {
            .container {
                padding: 0.5rem;
            }

            th, td {
                padding: 0.375rem 0.5rem;
            }

            .hide-mobile {
                display: none;
            }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .workflow-running {
            display: inline-block;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }

        .debug-footer {
            margin-top: 2rem;
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .debug-footer-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .debug-links {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem 1rem;
        }

        .debug-links a {
            color: var(--accent-blue);
            text-decoration: none;
            font-family: 'SF Mono', Monaco, Consolas, monospace;
        }

        .debug-links a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-left">
                <h1>d.ne4.org Backup</h1>
                <span id="buildInfo" class="build-info"></span>
            </div>
            <div class="last-updated">Last updated: <span id="lastUpdated">-</span></div>
        </header>

        <div class="grid">
            <div class="card">
                <div class="card-header">
                    <span class="card-title">Proxmox Backup Server</span>
                    <div class="status-indicator">
                        <div id="pbsDot" class="status-dot unknown"></div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                    <span style="font-size: 0.875rem; color: var(--text-secondary);">pbs.d.ne4.org</span>
                    <a href="https://pbs.d.ne4.org:8007/" target="_blank" rel="noopener noreferrer"
                       style="color: var(--accent-blue); display: flex; align-items: center;"
                       title="Open PBS Web Interface">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                    </a>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span style="font-size: 0.875rem; color: var(--text-secondary);">pbs-bmc.d.ne4.org</span>
                    <a href="http://pbs-bmc.d.ne4.org/" target="_blank" rel="noopener noreferrer"
                       style="color: var(--accent-blue); display: flex; align-items: center;"
                       title="Open BMC Web Interface">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                    </a>
                </div>
                <div id="pbsStatus" class="status-value">-</div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Next Workflow</span>
                    <div class="status-indicator">
                        <div id="nextRunDot" class="status-dot unknown"></div>
                    </div>
                </div>
                <div id="nextRunStatus" class="status-value">-</div>
                <div id="nextRunDetail" class="status-detail">Checking schedule...</div>
                <div id="nextRunWorkflows" class="status-detail" style="margin-top: 0.5rem; font-weight: 500;"></div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('workflows')">Workflows</button>
            <button class="tab" onclick="switchTab('current')">Current Workflow</button>
            <button class="tab" onclick="switchTab('history')">History</button>
            <button class="tab" onclick="switchTab('config')">Configuration</button>
        </div>

        <div id="workflowsTab" class="tab-content active">
            <div class="section">
                <div class="section-header">
                    <span class="section-title">Available Workflows</span>
                    <span id="workflowCount" class="card-title">0 workflows</span>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Workflow</th>
                            <th style="width: 120px; text-align: center;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="workflowsBody">
                        <tr>
                            <td colspan="2" class="empty-state">Loading workflows...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="currentTab" class="tab-content">
            <div class="section">
                <div class="section-header">
                    <span class="section-title">Current Workflow</span>
                    <span id="activityCount" class="card-title">No active workflow</span>
                </div>
                <table id="currentWorkflowTable" class="hidden">
                    <thead>
                        <tr>
                            <th style="width: 30px;"></th>
                            <th>Step</th>
                            <th>State</th>
                            <th>Status</th>
                            <th class="hide-mobile">Started</th>
                            <th class="hide-mobile">Ended</th>
                            <th>Duration</th>
                        </tr>
                    </thead>
                    <tbody id="activitiesBody">
                    </tbody>
                </table>
                <div id="currentWorkflowEmpty" class="empty-state">
                    No workflow is currently running
                </div>
            </div>
        </div>

        <div id="historyTab" class="tab-content">
            <div class="section">
                <div class="section-header">
                    <span class="section-title">Workflow History</span>
                    <span id="historyCount" class="card-title">0 runs</span>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30px;"></th>
                            <th>Workflows</th>
                            <th>Status</th>
                            <th>Started</th>
                            <th class="hide-mobile">Ended</th>
                            <th>Duration</th>
                            <th class="hide-mobile">Error</th>
                        </tr>
                    </thead>
                    <tbody id="historyBody">
                        <tr>
                            <td colspan="7" class="empty-state">Loading history...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="configTab" class="tab-content">
            <div class="section">
                <div class="section-header">
                    <span class="section-title">Configuration</span>
                </div>
                <div class="config-container">
                    <div class="config-actions">
                        <button class="btn btn-primary" onclick="reloadConfig()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                            Reload Config
                        </button>
                    </div>
                    <pre id="configYaml">Click Reload Config to load configuration...</pre>
                    <div id="configStatus" class="config-status"></div>
                </div>
            </div>
        </div>

        <footer class="debug-footer">
            <div class="debug-footer-title">Debug Endpoints</div>
            <div class="debug-links">
                <a href="/metrics">/metrics</a>
                <a href="/api/status">/api/status</a>
                <a href="/api/history">/api/history</a>
                <a href="/api/workflows">/api/workflows</a>
                <a href="/health">/health</a>
            </div>
        </footer>
    </div>

    <script>
        const POLL_INTERVAL_IDLE = 5000;
        const POLL_INTERVAL_RUNNING = 2000;
        let isRunning = false;
        let pollInterval = null;
        let expandedRows = new Set(); // Track which rows are expanded
        let currentExecutions = []; // Store current executions for expanding
        let availableWorkflows = [];
        let expandedHistoryRows = new Set(); // Track which history runs are expanded
        let expandedHistoryActivities = new Set(); // Track which activities within history are expanded
        let historyData = []; // Store history data for expansion
        let logsCache = new Map(); // Cache for run data including logs
        let activeFetches = new Set(); // Track in-flight log fetches

        async function fetchJSON(url) {
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            return resp.json();
        }

        function formatTime(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return date.toLocaleString('en-GB', { hour12: false });
        }

        function formatTimeShort(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return date.toLocaleTimeString('en-GB', { hour12: false });
        }

        function formatDuration(startStr, endStr) {
            if (!startStr) return '-';
            const start = new Date(startStr);
            const end = endStr ? new Date(endStr) : new Date();
            const diffMs = end - start;
            
            if (diffMs < 0) return '-';
            
            const seconds = Math.floor(diffMs / 1000) % 60;
            const minutes = Math.floor(diffMs / 60000) % 60;
            const hours = Math.floor(diffMs / 3600000);
            
            if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;
            if (minutes > 0) return `${minutes}m ${seconds}s`;
            return `${seconds}s`;
        }

        function formatRelativeTime(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            const now = new Date();
            const diffMs = date - now;

            if (diffMs < 0) return 'now';

            const seconds = Math.floor(diffMs / 1000) % 60;
            const minutes = Math.floor(diffMs / 60000) % 60;
            const hours = Math.floor(diffMs / 3600000) % 24;
            const days = Math.floor(diffMs / 86400000);

            if (days > 0) return `in ${days}d ${hours}h`;
            if (hours > 0) return `in ${hours}h ${minutes}m`;
            if (minutes > 0) return `in ${minutes}m`;
            return `in ${seconds}s`;
        }

        function formatUptime(isoString) {
            if (!isoString) return '-';
            const startDate = new Date(isoString);
            const now = new Date();
            const diffMs = now - startDate;

            if (diffMs < 0) return '-';

            const seconds = Math.floor(diffMs / 1000) % 60;
            const minutes = Math.floor(diffMs / 60000) % 60;
            const hours = Math.floor(diffMs / 3600000) % 24;
            const days = Math.floor(diffMs / 86400000);

            if (days > 0) return `${days}d ${hours}h ${minutes}m`;
            if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;
            if (minutes > 0) return `${minutes}m ${seconds}s`;
            return `${seconds}s`;
        }

        function updateLastUpdated() {
            document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
        }

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));

            // Find the correct tab button to activate
            const tabs = document.querySelectorAll('.tab');
            const tabNames = ['workflows', 'current', 'history', 'config'];
            const tabIndex = tabNames.indexOf(tab);
            if (tabIndex >= 0 && tabs[tabIndex]) {
                tabs[tabIndex].classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tab + 'Tab').classList.add('active');

            // Load config when switching to config tab
            if (tab === 'config' && !configLoaded) {
                fetchConfig();
            }

            // Load workflows when switching to workflows tab
            if (tab === 'workflows' && availableWorkflows.length === 0) {
                fetchAvailableWorkflows();
            }
        }

        function toggleActivityLogs(index) {
            const rowId = `activity-${index}`;
            const logsRow = document.getElementById(`logs-${index}`);
            const chevron = document.getElementById(`chevron-${index}`);

            if (expandedRows.has(rowId)) {
                expandedRows.delete(rowId);
                logsRow.style.display = 'none';
                chevron.classList.remove('expanded');
            } else {
                expandedRows.add(rowId);
                logsRow.style.display = 'table-row';
                chevron.classList.add('expanded');
            }
        }

        async function fetchLogs(runId) {
            if (activeFetches.has(runId)) return null;

            const run = historyData.find(r => r.id === runId);
            if (!run) return null;

            // Use cached logs if available and run is not running
            if (logsCache.has(runId) && run.state !== 'running') {
                return logsCache.get(runId);
            }

            activeFetches.add(runId);
            try {
                const executions = await fetchJSON(`/api/history/logs?id=${runId}`);
                logsCache.set(runId, executions);
                return executions;
            } catch (err) {
                console.error(`Failed to fetch logs for run ${runId}:`, err);
                return null;
            } finally {
                activeFetches.delete(runId);
            }
        }

        async function toggleHistoryRow(runId) {
            const logsRow = document.getElementById(`history-details-${runId}`);
            const chevron = document.getElementById(`history-chevron-${runId}`);
            const contentWrapper = document.getElementById(`history-content-${runId}`);

            if (expandedHistoryRows.has(runId)) {
                expandedHistoryRows.delete(runId);
                logsRow.style.display = 'none';
                chevron.classList.remove('expanded');
            } else {
                expandedHistoryRows.add(runId);
                logsRow.style.display = 'table-row';
                chevron.classList.add('expanded');

                // Show loading state if no logs in cache
                if (!logsCache.has(runId)) {
                    contentWrapper.innerHTML = '<div class="empty-state">Loading logs...</div>';
                }

                const executions = await fetchLogs(runId);
                if (executions) {
                    contentWrapper.innerHTML = renderHistoryActivityDetails(runId, executions);
                }
            }
        }

        function toggleHistoryActivity(runId, activityIndex) {
            const activityId = `${runId}-${activityIndex}`;
            const logsRow = document.getElementById(`history-activity-logs-${activityId}`);
            const chevron = document.getElementById(`history-activity-chevron-${activityId}`);

            if (expandedHistoryActivities.has(activityId)) {
                expandedHistoryActivities.delete(activityId);
                logsRow.style.display = 'none';
                chevron.classList.remove('expanded');
            } else {
                expandedHistoryActivities.add(activityId);
                logsRow.style.display = 'table-row';
                chevron.classList.add('expanded');
            }
        }

        function renderHistoryActivityDetails(runId, executions) {
            if (!executions || executions.length === 0) {
                return '<div class="empty-state" style="padding: 1rem;">No activity details available</div>';
            }

            return `
                <table style="background-color: var(--bg-primary); margin: 0; width: 100%;">
                    <thead>
                        <tr>
                            <th style="width: 30px;"></th>
                            <th>Step</th>
                            <th>State</th>
                            <th>Started</th>
                            <th class="hide-mobile">Ended</th>
                            <th>Duration</th>
                            <th class="hide-mobile">Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${executions.map((exec, index) => {
                            const displayName = exec.type || 'Unknown';
                            const startTime = exec.start_time && exec.start_time !== '0001-01-01T00:00:00Z'
                                ? exec.start_time : null;
                            const endTime = exec.end_time && exec.end_time !== '0001-01-01T00:00:00Z'
                                ? exec.end_time : null;
                            const errorMsg = exec.error ? exec.error : null;
                            const statusMsg = exec.status || '-';
                            const activityId = `${runId}-${index}`;
                            const isExpanded = expandedHistoryActivities.has(activityId);

                            return `
                                <tr class="expandable-row" onclick="toggleHistoryActivity('${runId}', ${index})">
                                    <td>
                                        <svg id="history-activity-chevron-${activityId}" class="chevron-icon ${isExpanded ? 'expanded' : ''}" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <polyline points="9 18 15 12 9 6"></polyline>
                                        </svg>
                                    </td>
                                    <td><span class="activity-name">${displayName}</span></td>
                                    <td>${getStateBadge(exec.state, errorMsg)}</td>
                                    <td><span class="timestamp">${formatTimeShort(startTime)}</span></td>
                                    <td class="hide-mobile"><span class="timestamp">${formatTimeShort(endTime)}</span></td>
                                    <td><span class="duration">${formatDuration(startTime, endTime)}</span></td>
                                    <td class="hide-mobile">${errorMsg ? `<span class="error-message" title="${errorMsg}">${errorMsg}</span>` : statusMsg}</td>
                                </tr>
                                <tr id="history-activity-logs-${activityId}" class="log-details" style="display: ${isExpanded ? 'table-row' : 'none'};">
                                    <td colspan="7">
                                        <div id="history-activity-logs-content-${activityId}" class="log-details-content">
                                            ${renderLogs(exec.logs)}
                                        </div>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
        }

        function formatLogTime(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return date.toLocaleTimeString('en-GB', { hour12: false });
        }

        function renderLogs(logs) {
            if (!logs || logs.length === 0) {
                return '<div class="empty-state" style="padding: 1rem;">No logs captured for this activity</div>';
            }

            const reversedLogs = [...logs].reverse();
            return reversedLogs.map(log => {
                const attrs = log.attributes && Object.keys(log.attributes).length > 0
                    ? '<div class="log-attributes">' +
                      Object.entries(log.attributes).map(([key, val]) =>
                        `<span class="log-attr-key">${key}</span>: ${JSON.stringify(val)}`
                      ).join(', ') +
                      '</div>'
                    : '';

                return `<div class="log-entry">
                    <span class="log-time">${formatLogTime(log.time)}</span>
                    <span class="log-level ${log.level}">${log.level}</span>
                    <span class="log-message">${log.message}${attrs}</span>
                </div>`;
            }).join('');
        }

        function getStateBadge(state, error) {
            const stateMap = {
                'not_started': { class: 'badge-pending', text: 'Pending' },
                'pending': { class: 'badge-pending', text: 'Pending' },
                'running': { class: 'badge-running', text: 'Running' },
                'skipped': { class: 'badge-skipped', text: 'Skipped' },
                'completed': error ? { class: 'badge-error', text: 'Failed' } : { class: 'badge-success', text: 'Success' }
            };
            const badge = stateMap[state] || { class: 'badge-pending', text: state };
            return `<span class="badge ${badge.class}">${badge.text}</span>`;
        }

        function saveScrollPositions() {
            const positions = new Map();
            document.querySelectorAll('.log-details-content').forEach(el => {
                if (el.id) {
                    positions.set(el.id, {
                        scrollTop: el.scrollTop,
                        scrollHeight: el.scrollHeight,
                        atTop: el.scrollTop === 0
                    });
                }
            });
            return positions;
        }

        function restoreScrollPositions(positions) {
            document.querySelectorAll('.log-details-content').forEach(el => {
                const pos = positions.get(el.id);
                if (pos) {
                    if (pos.atTop) {
                        el.scrollTop = 0;
                    } else {
                        const newScrollHeight = el.scrollHeight;
                        const heightDiff = newScrollHeight - pos.scrollHeight;
                        el.scrollTop = pos.scrollTop + heightDiff;
                    }
                }
            });
        }

        async function updateAPIStatus() {
            try {
                const data = await fetchJSON('/api/status');

                // Update PBS status
                const pbsState = data.pbs.power_state.toLowerCase();
                const pbsDot = document.getElementById('pbsDot');
                const pbsStatus = document.getElementById('pbsStatus');

                pbsDot.className = 'status-dot ' + (pbsState === 'on' ? 'on' : pbsState === 'off' ? 'off' : 'unknown');
                pbsStatus.textContent = pbsState.charAt(0).toUpperCase() + pbsState.slice(1);
                pbsStatus.className = 'status-value ' + (pbsState === 'on' ? 'on' : pbsState === 'off' ? 'off' : '');

                // Update build info, uptime, and hostname
                const buildInfo = document.getElementById('buildInfo');
                let buildText = '';
                if (data.server && data.server.build && data.server.build.build_time !== 'unknown') {
                    // Parse build time (format: YYYY-MM-DD_HH:MM:SS) and format for AU
                    const buildDate = data.server.build.build_time.replace('_', 'T');
                    const date = new Date(buildDate);
                    const formatted = date.toLocaleDateString('en-AU', {
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    });
                    const commit = data.server.build.git_commit || 'unknown';
                    buildText = `Built ${formatted} (${commit})`;
                }
                if (data.server && data.server.started_at) {
                    const startDate = new Date(data.server.started_at);
                    const startFormatted = startDate.toLocaleDateString('en-AU', {
                        day: 'numeric',
                        month: 'short',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    });
                    buildText += buildText ? ` · Started ${startFormatted}` : `Started ${startFormatted}`;
                }
                if (data.server && data.server.hostname) {
                    buildText += buildText ? ` · ${data.server.hostname}` : data.server.hostname;
                }
                buildInfo.textContent = buildText;

                // Update run status
                const wasRunning = isRunning;
                isRunning = data.run.state === 'running';

                // Adjust poll interval when state changes
                if (wasRunning !== isRunning) {
                    clearInterval(pollInterval);
                    pollInterval = setInterval(updateAll, isRunning ? POLL_INTERVAL_RUNNING : POLL_INTERVAL_IDLE);
                }

                // Update next run
                const nextRunDot = document.getElementById('nextRunDot');
                const nextRunStatus = document.getElementById('nextRunStatus');
                const nextRunDetail = document.getElementById('nextRunDetail');

                const nextRunWorkflowsDiv = document.getElementById('nextRunWorkflows');

                if (data.next_run.scheduled && data.next_run.next_run) {
                    nextRunDot.className = 'status-dot scheduled';
                    nextRunStatus.textContent = formatRelativeTime(data.next_run.next_run);
                    nextRunDetail.textContent = formatTime(data.next_run.next_run);

                    if (data.next_run.workflows && data.next_run.workflows.length > 0) {
                        nextRunWorkflowsDiv.textContent = `Workflows: ${data.next_run.workflows.join(', ')}`;
                    } else {
                        nextRunWorkflowsDiv.textContent = '';
                    }
                } else {
                    nextRunDot.className = 'status-dot not-scheduled';
                    nextRunStatus.textContent = 'Not scheduled';
                    nextRunDetail.textContent = 'No cron schedule configured';
                    nextRunWorkflowsDiv.textContent = '';
                }

                // Update activity executions
                const table = document.getElementById('currentWorkflowTable');
                const emptyState = document.getElementById('currentWorkflowEmpty');
                const tbody = document.getElementById('activitiesBody');
                const count = document.getElementById('activityCount');

                const executions = data.run.activity_executions || [];
                currentExecutions = executions; // Store for expand/collapse

                if (!isRunning || executions.length === 0) {
                    table.classList.add('hidden');
                    emptyState.classList.remove('hidden');
                    count.textContent = 'No active workflow';
                } else {
                    // Backend provides stable alphabetical order
                    table.classList.remove('hidden');
                    emptyState.classList.add('hidden');
                    count.textContent = `${executions.length} activit${executions.length !== 1 ? 'ies' : 'y'}`;

                    const scrollPos = saveScrollPositions();
                    tbody.innerHTML = executions.map((exec, index) => {
                        const displayName = exec.type || 'Unknown';
                        const startTime = exec.start_time && exec.start_time !== '0001-01-01T00:00:00Z'
                            ? exec.start_time : null;
                        const endTime = exec.end_time && exec.end_time !== '0001-01-01T00:00:00Z'
                            ? exec.end_time : null;
                        const errorMsg = exec.error ? exec.error : null;
                        const statusMsg = exec.status || '-';
                        const isExpanded = expandedRows.has(`activity-${index}`);

                        return `
                            <tr class="expandable-row" onclick="toggleActivityLogs(${index})">
                                <td>
                                    <svg id="chevron-${index}" class="chevron-icon ${isExpanded ? 'expanded' : ''}" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="9 18 15 12 9 6"></polyline>
                                    </svg>
                                </td>
                                <td><span class="activity-name">${displayName}</span></td>
                                <td>${getStateBadge(exec.state, errorMsg)}</td>
                                <td>${statusMsg}</td>
                                <td class="hide-mobile"><span class="timestamp">${formatTimeShort(startTime)}</span></td>
                                <td class="hide-mobile"><span class="timestamp">${formatTimeShort(endTime)}</span></td>
                                <td><span class="duration">${formatDuration(startTime, endTime)}</span></td>
                            </tr>
                            <tr id="logs-${index}" class="log-details" style="display: ${isExpanded ? 'table-row' : 'none'};">
                                <td colspan="7">
                                    <div id="current-activity-logs-${index}" class="log-details-content">
                                        ${renderLogs(exec.logs)}
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('');
                    restoreScrollPositions(scrollPos);
                }

                // Update workflows tab with running status
                if (availableWorkflows.length > 0) {
                    const runningWorkflows = data.run.state === 'running' ? data.run.workflows : [];
                    updateWorkflowsTab(runningWorkflows);

                    // Also disable buttons when any workflow is running
                    availableWorkflows.forEach(wf => {
                        const btn = document.getElementById(`run-btn-${wf}`);
                        if (btn) {
                            btn.disabled = isRunning;
                        }
                    });
                }
            } catch (err) {
                document.getElementById('pbsStatus').textContent = 'Unknown';
                document.getElementById('pbsDot').className = 'status-dot unknown';
                document.getElementById('nextRunStatus').textContent = 'Error';
                document.getElementById('nextRunDetail').textContent = err.message;
            }
        }

        async function updateHistory() {
            try {
                const data = await fetchJSON('/api/history');
                historyData = data;
                const tbody = document.getElementById('historyBody');
                const count = document.getElementById('historyCount');

                count.textContent = `${data.length} run${data.length !== 1 ? 's' : ''}`;

                if (data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" class="empty-state">No backup runs yet</td></tr>';
                    return;
                }

                const scrollPos = saveScrollPositions();
                tbody.innerHTML = data.map(run => {
                    const isSuccess = run.state !== 'running' && !run.error;
                    const isError = run.state !== 'running' && run.error;
                    const runIsRunning = run.state === 'running';

                    let badgeClass = 'badge-success';
                    let badgeText = 'Success';

                    if (runIsRunning) {
                        badgeClass = 'badge-running';
                        badgeText = 'Running';
                    } else if (isError) {
                        badgeClass = 'badge-error';
                        badgeText = 'Failed';
                    }

                    const runId = run.id;
                    const isExpanded = expandedHistoryRows.has(runId);
                    const workflows = run.workflows && run.workflows.length > 0
                        ? run.workflows.join(', ')
                        : '-';

                    let content = '';
                    if (isExpanded) {
                        const cached = logsCache.get(runId);
                        content = cached ? renderHistoryActivityDetails(runId, cached) : '<div class="empty-state">Loading logs...</div>';

                        // If it's expanded and running, we might want to refresh logs
                        if (runIsRunning) {
                            fetchLogs(runId).then(executions => {
                                const wrapper = document.getElementById(`history-content-${runId}`);
                                if (wrapper && executions) {
                                    const innerScrollPos = saveScrollPositions();
                                    wrapper.innerHTML = renderHistoryActivityDetails(runId, executions);
                                    restoreScrollPositions(innerScrollPos);
                                }
                            });
                        }
                    }

                    return `
                        <tr class="expandable-row" onclick="toggleHistoryRow('${runId}')">
                            <td>
                                <svg id="history-chevron-${runId}" class="chevron-icon ${isExpanded ? 'expanded' : ''}" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </td>
                            <td>${workflows}</td>
                            <td><span class="badge ${badgeClass}">${badgeText}</span></td>
                            <td><span class="timestamp">${formatTime(run.started_at)}</span></td>
                            <td class="hide-mobile"><span class="timestamp">${formatTime(run.ended_at)}</span></td>
                            <td><span class="duration">${formatDuration(run.started_at, run.ended_at)}</span></td>
                            <td class="hide-mobile">${run.error ? `<span class="error-message" title="${run.error}">${run.error}</span>` : '-'}</td>
                        </tr>
                        <tr id="history-details-${runId}" class="log-details" style="display: ${isExpanded ? 'table-row' : 'none'};">
                            <td colspan="7">
                                <div id="history-content-${runId}" class="log-details-content-wrapper">
                                    ${content}
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
                restoreScrollPositions(scrollPos);
            } catch (err) {
                document.getElementById('historyBody').innerHTML =
                    `<tr><td colspan="7" class="empty-state">Failed to load history: ${err.message}</td></tr>`;
            }
        }

        async function triggerBackup() {
            const btn = document.getElementById('runBtn');
            const detail = document.getElementById('actionDetail');
            
            btn.disabled = true;
            detail.textContent = 'Starting backup...';

            try {
                const resp = await fetch('/run', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({workflows: ['backup', 'poweroff']})
                });
                if (resp.status === 202) {
                    detail.textContent = 'Backup started successfully';
                    detail.style.color = 'var(--accent-green)';
                    await updateAll();
                } else if (resp.status === 409) {
                    detail.textContent = 'A backup is already running';
                    detail.style.color = 'var(--accent-yellow)';
                } else {
                    const data = await resp.json();
                    detail.textContent = data.error || 'Failed to start backup';
                    detail.style.color = 'var(--accent-red)';
                }
            } catch (err) {
                detail.textContent = err.message;
                detail.style.color = 'var(--accent-red)';
            }

            setTimeout(() => {
                detail.textContent = '';
                detail.style.color = '';
            }, 5000);
        }

        async function fetchAvailableWorkflows() {
            try {
                const data = await fetchJSON('/api/workflows');
                availableWorkflows = data.workflows || [];
                updateWorkflowsTab();
            } catch (err) {
                const tbody = document.getElementById('workflowsBody');
                tbody.innerHTML = `<tr><td colspan="2" class="empty-state">Failed to load workflows: ${err.message}</td></tr>`;
            }
        }

        function updateWorkflowsTab(runningWorkflows = []) {
            const tbody = document.getElementById('workflowsBody');
            const count = document.getElementById('workflowCount');

            count.textContent = `${availableWorkflows.length} workflow${availableWorkflows.length !== 1 ? 's' : ''}`;

            if (availableWorkflows.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" class="empty-state">No workflows available</td></tr>';
                return;
            }

            const sorted = [...availableWorkflows].sort();

            tbody.innerHTML = sorted.map(workflow => {
                const isRunning = runningWorkflows.includes(workflow);
                const runningIcon = isRunning ? `
                    <svg class="workflow-running" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                ` : '';

                return `
                <tr>
                    <td>
                        ${runningIcon}<span class="activity-name">${workflow}</span>
                    </td>
                    <td style="text-align: center;">
                        <button class="btn btn-primary" onclick="runSingleWorkflow('${workflow}')"
                                id="run-btn-${workflow}" style="padding: 0.5rem 1rem; font-size: 0.75rem;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            Run
                        </button>
                    </td>
                </tr>
                `;
            }).join('');
        }

        async function runSingleWorkflow(workflowName) {
            const btn = document.getElementById(`run-btn-${workflowName}`);
            if (!btn) return;

            // Disable all run buttons
            availableWorkflows.forEach(wf => {
                const b = document.getElementById(`run-btn-${wf}`);
                if (b) b.disabled = true;
            });

            const originalHtml = btn.innerHTML;
            btn.innerHTML = `Running...`;

            try {
                const resp = await fetch('/run', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({workflows: [workflowName]})
                });

                if (resp.status === 202) {
                    switchTab('current');
                    await updateAll();
                } else if (resp.status === 409) {
                    alert('A workflow is already running. Please wait for it to complete.');
                } else {
                    const data = await resp.json();
                    alert(`Failed to start workflow: ${data.error || 'Unknown error'}`);
                }
            } catch (err) {
                alert(`Error starting workflow: ${err.message}`);
            } finally {
                setTimeout(() => {
                    availableWorkflows.forEach(wf => {
                        const b = document.getElementById(`run-btn-${wf}`);
                        if (b) {
                            b.disabled = isRunning;
                            if (wf === workflowName) {
                                b.innerHTML = originalHtml;
                            }
                        }
                    });
                }, 1000);
            }
        }

        async function updateAll() {
            await Promise.all([updateAPIStatus(), updateHistory()]);
            updateLastUpdated();
        }

        let configLoaded = false;

        async function fetchConfig() {
            const configYaml = document.getElementById('configYaml');
            const configStatus = document.getElementById('configStatus');

            try {
                configYaml.textContent = 'Loading configuration...';
                configStatus.textContent = '';

                const resp = await fetch('/config');
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

                const yamlText = await resp.text();
                configYaml.textContent = yamlText;
                configLoaded = true;
            } catch (err) {
                configYaml.textContent = 'Failed to load configuration';
                configStatus.textContent = `Error: ${err.message}`;
                configStatus.style.color = 'var(--accent-red)';
            }
        }

        async function reloadConfig() {
            const configStatus = document.getElementById('configStatus');

            try {
                configStatus.textContent = 'Reloading configuration...';
                configStatus.style.color = 'var(--text-secondary)';

                const resp = await fetch('/reload', { method: 'POST' });

                if (resp.status === 204) {
                    configStatus.textContent = 'Configuration reloaded successfully';
                    configStatus.style.color = 'var(--accent-green)';

                    // Refresh the config display
                    configLoaded = false;
                    await fetchConfig();
                } else {
                    const data = await resp.json();
                    configStatus.textContent = `Failed to reload: ${data.error || 'Unknown error'}`;
                    configStatus.style.color = 'var(--accent-red)';
                }
            } catch (err) {
                configStatus.textContent = `Error: ${err.message}`;
                configStatus.style.color = 'var(--accent-red)';
            }

            // Clear status after 5 seconds
            setTimeout(() => {
                configStatus.textContent = '';
                configStatus.style.color = '';
            }, 5000);
        }

        // Initial load
        updateAll();
        fetchAvailableWorkflows();

        // Poll for updates (starts with idle interval)
        pollInterval = setInterval(updateAll, POLL_INTERVAL_IDLE);
    </script>
</body>
</html>
